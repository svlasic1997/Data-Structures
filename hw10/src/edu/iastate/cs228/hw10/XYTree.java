package edu.iastate.cs228.hw10;import java.util.LinkedList;/** * A class that implements an xy-tree. *  * @author Scott Vlasic *  *  *  *  * NOTEs and REQUIREMENTs: *  * 0. Put your Firstname and Lastname after above empty author tag.  * Make sure that in both cases the first letter is uppercase and  * all others are composed of lowercase letters. *  * 1. You are allowed to create and use your own private helper  * methods. If you are introducing your own helper methods those * need to be private ONLY and properly documented as per Javadoc  * style. Provided constructors/methods declarations cannot be changed. *  * 2. No additional data fields can be introduced in the class below. * Or any other class provided as part of this HW. You are not allowed  * to change the case of the already existing data fields, or rename those. *  * 3. No custom classes of your own can be introduced or used.  *  * 4. Import statements are not allowed.  *  * 5. Fully qualified class names usage is not allowed. Exception is  * for levelOrderTraverse method ONLY, where you are allowed to use  * ONLY java.util.LinkedList class. *  * 6. You are allowed to reuse any part of the provided source codes  * or shown under lecture notes section of Canvas, which do not violate  * any of the requirements. *  * 7. If you have any additional questions PLEASE ask on Piazza Q/A  * platform, however, before posting a question PLEASE, first, search * the Q/A platform to see if the same question was not already asked  * and answered. PLEASE setup your notifications for both Canvas and  * Piazza so that you are updated, immediately, whenever there are any  * changes happen either on Canvas or Piazza Q/A platform. *  * 8. You need to provide implementation to all methods which have a  * comment //TODO in their body. In this HW there 3 of those, i.e., * addPoint, contains, and leverlOrderTraverse. For all of these methods  * there is no need to provide comments. Same, i.e., no comments, applies * also for all provided classes/interfaces, including their  * constructors/methods which you are not required to implement as part  * of this HW.    *  * 9.You can assume that x and y values of every Point will always be * int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T>{  private BinaryNode<T> root;  public XYTree()  {	root = null;  }  public XYTree(T rootData)  {	if (rootData != null)	  root = new BinaryNode<>(rootData);	else	  throw new IllegalArgumentException();  }  public void addAllPoints(T[] entries)  {	if (entries == null || entries.length == 0)	  throw new IllegalArgumentException();	for (T t : entries)	  addPoint(t);  }  /**   *   * Adds a new point into the xy-tree if it does not    * exist in this tree. Check an example under Canvas.   * Also, check the comment of levelOrderTraverse.   *    */  public void addPoint(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException(); 	// Checks if it's empty	if(root==null)	{		root = new BinaryNode<>(anEntry);		return;	}		int level = 0; // Level to see if comparing x or y values	BinaryNode<T> rootNode = root;	BinaryNode<T> newNode = new BinaryNode<>(anEntry);		while(true)	{		// Checks if level is even (check the x values)		if(level % 2==0)		{			if(rootNode.getData().x == anEntry.x && rootNode.getData().y == anEntry.y)			{				return;			}						if(rootNode.getData().x < anEntry.x)			{				if(rootNode.getRightChild()==null)				{					rootNode.setRightChild(newNode);					return;				}								rootNode = rootNode.getRightChild();			}			else			{				if(rootNode.getLeftChild()==null)				{					rootNode.setLeftChild(newNode);					return;				}								rootNode = rootNode.getLeftChild();			}		}		else		{			// Otherwise the level is odd and check the y values			if(rootNode.getData().x==anEntry.x && rootNode.getData().y==anEntry.y)			{				return;			}						if(rootNode.getData().y < anEntry.y)			{				if(rootNode.getRightChild()==null)				{					rootNode.setRightChild(newNode);					return;				}								rootNode = rootNode.getRightChild();			}			else			{				if(rootNode.getLeftChild()==null)				{					rootNode.setLeftChild(newNode);					return;				}								rootNode = rootNode.getLeftChild();			}		}				level++;	}  }  /**   * Returns true if a point exists in this tree,    * otherwise false.   *    */  public boolean contains(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException();	int level = 0;	BinaryNode<T> rootNode = root;		while(rootNode!=null)	{		if(level % 2==0)		{			if(rootNode.getData().x == anEntry.x && rootNode.getData().y == anEntry.y)			{				return true;			}						if(rootNode.getData().x < anEntry.x)			{				if(rootNode.getRightChild()==null)				{					break;				}								rootNode = rootNode.getRightChild();			}			else			{				if(rootNode.getLeftChild()==null)				{					break;				}								rootNode = rootNode.getLeftChild();			}		}		else		{			if(rootNode.getData().x == anEntry.x && rootNode.getData().y == anEntry.y)			{				return true;			}						if(rootNode.getData().y < anEntry.y)			{				if(rootNode.getRightChild()==null)				{					break;				}								rootNode = rootNode.getRightChild();			}			else			{				if(rootNode.getLeftChild()==null)				{					break;				}								rootNode = rootNode.getLeftChild();			}		}				level++;	}		return false;  }  /**   * Returns a list of points in level-order traversal.    * In this method you are allowed to use    * java.util.LinkedList class.   *    *    * For example,   *    * XYTree<Point> xy = new XYTree<>();    *    * xy.addAllPoints(new Point[]{   * 	new Point(5, 3),    *    new Point(5, 2),    *    new Point(10, 7),    *    new Point(9, 1),    *    new Point(6, 8),    *    new Point(6, 8),    *    new Point(10, 1)   * });   * System.out.println(xy.levelOrderTraverse());   *    * would print   *    * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]   *    */  public java.util.LinkedList<String> levelOrderTraverse()  {	LinkedList<String> queue = new LinkedList<String>();	LinkedList<BinaryNode<T>> binaryList = new LinkedList<BinaryNode<T>>();	if(root == null){	    return queue;	}		binaryList.add(root);	int length = root.getNumberOfNodes();	int added = 0;		while(!binaryList.isEmpty())	{		BinaryNode<T> temp = binaryList.poll();				if(added==0)		{			queue.add("(" + temp.getData().x + ", " + temp.getData().y + ")");		}		else if(added==length-1)		{			queue.add("(" + temp.getData().x + ", " + temp.getData().y + ")");		}		else		{			queue.add("(" + temp.getData().x + ", " + temp.getData().y + ")");					}				if(temp.hasLeftChild())		{			binaryList.add(temp.getLeftChild());		}				if(temp.hasRightChild())		{			binaryList.add(temp.getRightChild());		}		added++;	}	return queue;  }  @Override  @SuppressWarnings("unchecked")  public T getRootData()  {	if (isEmpty())	  throw new RuntimeException("Empty Tree!");	else	  return (T) root.getData().clone();  }  @Override  public boolean isEmpty()  {	return root == null;  }  @Override  public void clear()  {	root = null;  }  @Override  public int getHeight()  {	return root.getHeight();  }  @Override  public int getNumberOfNodes()  {	return root.getNumberOfNodes();  }}