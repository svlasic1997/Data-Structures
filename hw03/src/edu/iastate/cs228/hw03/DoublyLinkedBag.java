package edu.iastate.cs228.hw03;/**   A class of bags whose entries are stored in a chain of doubly linked nodes.       @author	Scott Vlasic    */public class DoublyLinkedBag<T> implements BagInterface<T>{	private DoublyLinkedNode firstNode;       // Reference to first node	private int numberOfEntries;	public DoublyLinkedBag()	{		firstNode = null;		numberOfEntries = 0;	} // end default constructor		public boolean add(T newEntry)	{				DoublyLinkedNode newNode = new DoublyLinkedNode(newEntry);		newNode.next = firstNode;				firstNode = newNode;		numberOfEntries++;				return true;	} // end add	public T[] toArray()	{		 @SuppressWarnings("unchecked")	     T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast	     int index = 0;	     DoublyLinkedNode currentNode = firstNode;	     while ((index < numberOfEntries) && (currentNode != null)){	        result[index] = currentNode.data;	        index++;	        currentNode = currentNode.next;	     } // end while	      			return result;	} // end toArray	public boolean isEmpty() 	{		return numberOfEntries == 0;	} // end isEmpty	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	public int getFrequencyOf(T anEntry) 	{		int frequency = 0;	      int counter = 0;	      DoublyLinkedNode currentNode = firstNode;	      while ((counter < numberOfEntries) && (currentNode != null))	      {	         if (anEntry.equals(currentNode.data))	         {	            frequency++;	         } // end if	         	         counter++;	         currentNode = currentNode.next;	      } // end while			return frequency;	} // end getFrequencyOf	public boolean contains(T anEntry)	{		 boolean found = false;	     DoublyLinkedNode currentNode = firstNode;	      	      while (!found && (currentNode != null))	      {	         if (anEntry.equals(currentNode.data))	            found = true;	         else	            currentNode = currentNode.next;	      } // end while		      	      return found;	} // end contains	public void clear() 	{		while (!isEmpty()) 	    remove();	} // end clear	public T remove()	{				T result = null;	    if (firstNode != null)	    {	       result = firstNode.data; 	       firstNode = firstNode.next; // Remove first node from chain	       numberOfEntries--;	     } // end if		return result;	} // end remove	public boolean remove(T anEntry) 	{		boolean result = false;	    DoublyLinkedNode nodeN = firstNode;	      	     if (nodeN != null)	     {	       nodeN.data = firstNode.data; // Replace located entry with entry in first node	         	        firstNode = firstNode.next;  // Remove first node	        numberOfEntries--;	         	         result = true;	      } // end if	         			return result;	} // end remove	public T replace(T replacement)	{		T entryReplaced = null; // Entry to be replaced				DoublyLinkedNode firstNode = this.firstNode; // Variable for the first node						if(isEmpty()){						return null; // If empty return null					}		// While it's not empty and there are no null values loop through 		while(!isEmpty() && firstNode != null){						// If there is a next value hop into the if statement			if(firstNode.next != null){								entryReplaced = firstNode.data; // Set the entry replaced to be the firstNode data							firstNode.data = replacement; // Set the firstNode data equal to the local variable			}						firstNode = firstNode.next; // Sets firstNode to the next value		}						return entryReplaced; // Returns the replaced entry	}			public void removeEvery(T anEntry)	{				DoublyLinkedNode firstNode = this.firstNode;				while(firstNode != null){						if(firstNode.data.equals(anEntry)){								firstNode.data = this.firstNode.data;				this.firstNode = this.firstNode.next;				numberOfEntries--;							}						firstNode = firstNode.next;					}			}		/**	 Override the equals method of Object class so that it returns true when the contents of two DoublyLinkedBags are same. Note that two equal DoublyLinkedBags contain the same number of entries, and each entry occurs in each DoublyLinkedBag the same number of times. I.e., the elements in two do not need to be in exact same location.	 	 Before checking the contents inside this method make sure that the passed in object is not null, is of the same runtime class, and the lengths are same. If any of these fail you can return false. Otherwise, you base your return results on contents. (At the start you can also do the quick check if both refer to the same object in memory.)	 	*/	@Override	public boolean equals(Object obj)	{				@SuppressWarnings("unchecked")		DoublyLinkedBag<T> otherBag = (DoublyLinkedBag<T>)obj;				DoublyLinkedNode firstNode = this.firstNode;				if(otherBag == null || otherBag.getClass() != this.getClass() || otherBag.getCurrentSize() != this.getCurrentSize()){						return false;					}				while(firstNode != null){						if(!(otherBag.contains(firstNode.data))){								return false;			}						else if(this.getFrequencyOf(firstNode.data) != otherBag.getFrequencyOf(firstNode.data)){								return false;							}						firstNode = firstNode.next;		}				return true;			}		/**	 Returns String representation of the items in this bag.	 For example, it would return [A, B, C] if bag had three Strings "A", "B", and "C".	 	 @return String representation of items in this bag enclosed in square brackets, separated by comma and a single space (see example above). You can rely on the fact that items' proper toString method was implemented. In this method ONLY if you need to you can use String class's methods. Also, ONLY in this method you can use fully qualified name for StringBuffer class, and use all of its methods.	*/	@Override	public String toString()	{				String s = "[";				DoublyLinkedNode firstNode = this.firstNode;				if(firstNode == null){			return "[]"; // this is returned in case bag is empty.		}						if(numberOfEntries == 1){			s += firstNode.data;			firstNode = firstNode.next;		}				while(firstNode != null && numberOfEntries > 1){						s += firstNode.data;			firstNode = firstNode.next;						if(firstNode == null){								break;			}						else{				s+= ", ";			}		}						return s + "]";	}		// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode	{		private T	data;					// Entry in bag		private DoublyLinkedNode next;		// Link to next node		private DoublyLinkedNode prev;	// Link to previous node		private DoublyLinkedNode(T dataPortion)		{			this(dataPortion, null, null);			} // end constructor		private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode,				DoublyLinkedNode previousNode)		{			data = dataPortion;			next = nextNode;			prev = previousNode;		} // end constructor			} // end DoublyLinkedNode} // end DoublyLinkedBag