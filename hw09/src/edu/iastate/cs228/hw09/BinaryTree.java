package edu.iastate.cs228.hw09;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;import java.util.Queue;import java.util.Stack;/** *  * A class that implements the ADT binary tree. *  * @author Frank M. Carrano * @author Timothy M. Henry * @author Scott Vlasic *  *  * NOTEs and REQUIREMENTs: *   * 0. Put your Firstname and Lastname after above empty author tag. * 	  Make sure that in both cases the first letter is uppercase *    and all others are lowercase. * 1. You are allowed to create and use your own private helper methods. * 	  If you are introducing your own helper methods those need to be  *    private and properly documented as per Javadoc style, i.e., you *    are not allowed to have public helper method. Already existing  *    methods declaration cannot be changed.      * 2. No additional data fields can be introduced in any of the  *    classes below. You are not allowed to change the case of the ones *    already existing, or rename those. Except where it's explicitly *    mentioned that you are allowed. * 3. No custom classes of your own can be introduced or used. * 4. Import statements are not allowed, besides the ones that are *    already provided. * 5. Fully qualified class names usage is not allowed. * 6. You are allowed to reuse any part of the provided source codes *    or shown under lecture notes section of Canvas, which do not  *    violate any of above. * 7. Check carefully the lecture notes of Week 10 named  *    "treeImpls_part2.pdf" for hints (and partial solutions) for *    this HW's required parts.    * 8. If you have any additional questions PLEASE ask on Piazza Q/A *    platform, but first PLEASE search and make sure that it was not *    already asked and answered. PLEASE setup your notifications for  *    both Canvas and Piazza so that you are updated whenever there *    are any changes immediately. * 9. You need to provide implementation to all methods and constructors *    which have a comment //TODO in their body. For all of these methods *    and constructors there is no need to provide comments. (Latter *    part applies also for all provided classes/interfaces, including *    the constructors/methods which you are not required to implement *    as part of this HW.) * 10.You can assume that data of each node of binary tree will never *    be null. *     *  */public class BinaryTree<T> implements BinaryTreeInterface<T>{  private BinaryNode<T> root;  public BinaryTree()  {	root = null;  } // end default constructor  public BinaryTree(T rootData)  {	root = new BinaryNode<>(rootData);  } // end constructor  public BinaryTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree)  {	privateSetTree(rootData, leftTree, rightTree);  } // end constructor  public void setTree(T rootData)  {	root = new BinaryNode<>(rootData);  } // end setTree  public void setTree(T rootData, BinaryTreeInterface<T> leftTree, BinaryTreeInterface<T> rightTree)  {	privateSetTree(rootData, (BinaryTree<T>) leftTree, (BinaryTree<T>) rightTree);  } // end setTree  private void privateSetTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree)  {	root = new BinaryNode<>(rootData);	if ((leftTree != null) && !leftTree.isEmpty())	  root.setLeftChild(leftTree.root);	if ((rightTree != null) && !rightTree.isEmpty())	{	  if (rightTree != leftTree)		root.setRightChild(rightTree.root);	  else		root.setRightChild(rightTree.root.copy());	} // end if	if ((leftTree != null) && (leftTree != this))	  leftTree.clear();	if ((rightTree != null) && (rightTree != this))	  rightTree.clear();  } // end privateSetTree  public T getRootData()  {	if (isEmpty())	  throw new EmptyTreeException();	else	  return root.getData();  } // end getRootData  public boolean isEmpty()  {	return root == null;  } // end isEmpty  public void clear()  {	root = null;  } // end clear  public void setRootData(T rootData)  {	root.setData(rootData);  } // end setRootData  public void setRootNode(BinaryNode<T> rootNode)  {	root = rootNode;  } // end setRootNode  public BinaryNode<T> getRootNode()  {	return root;  } // end getRootNode  public int getHeight()  {	return root.getHeight();  } // end getHeight  public int getNumberOfNodes()  {	return root.getNumberOfNodes();  } // end getNumberOfNodes  public Iterator<T> getPreorderIterator()  {	return new PreorderIterator();  } // end getPreorderIterator  public Iterator<T> getInorderIterator()  {	return new InorderIterator();  } // end getInorderIterator  public Iterator<T> getPostorderIterator()  {	return new PostorderIterator();  } // end getPostorderIterator  public Iterator<T> getLevelOrderIterator()  {	return new LevelOrderIterator();  } // end getLevelOrderIterator    private class InorderIterator implements Iterator<T>  {	private Stack<BinaryNode<T>> nodeStack;	private BinaryNode<T> currentNode;	public InorderIterator()	{	  nodeStack = new Stack<>();	  currentNode = root;	} // end default constructor	public boolean hasNext()	{	  return !nodeStack.empty() || (currentNode != null);	} // end hasNext	public T next()	{	  BinaryNode<T> nextNode = null;	  while (currentNode != null)	  {		nodeStack.push(currentNode);		currentNode = currentNode.getLeftChild();	  }	  if (!nodeStack.empty())	  {		nextNode = nodeStack.pop();		assert nextNode != null;		currentNode = nextNode.getRightChild();	  } 	  else throw new NoSuchElementException();	  return nextNode.getData();	}	  } // end InorderIterator  public void iterativeInorderTraverse()  {	Stack<BinaryNode<T>> nodeStack = new Stack<>();	BinaryNode<T> currentNode = root;	while (!nodeStack.isEmpty() || (currentNode != null))	{	  while (currentNode != null)	  {		nodeStack.push(currentNode);		currentNode = currentNode.getLeftChild();	  }	  if (!nodeStack.isEmpty())	  {		BinaryNode<T> nextNode = nodeStack.pop();		assert nextNode != null;		System.out.print(nextNode.getData() + " ");		currentNode = nextNode.getRightChild();	  }	}  } // end iterativeInorderTraverse      /**   * Outputs exact same info as iterativeInorderTraverse()   * method but for preorder traversal. You need to use Stack    * to implement this method iteratively.     */  public void iterativePreorderTraverse()  {	Stack<BinaryNode<T>> nodeStack = new Stack<>();	BinaryNode<T> currentNode = root;		if(currentNode == null){		return;	}		nodeStack.push(currentNode);		while(!nodeStack.isEmpty()){				BinaryNode<T> myNode = nodeStack.peek();		System.out.print(myNode.getData() + " ");		nodeStack.pop();				if(myNode.getRightChild() != null){			nodeStack.push(myNode.getRightChild());		}				if(myNode.getLeftChild() != null){			nodeStack.push(myNode.getLeftChild());		}	}	  }  /**   * Outputs exact same info as iterativeInorderTraverse()   * method but for postorder traversal. You need to use    * Stack to implement this method iteratively.    */  public void iterativePostorderTraverse()  {	Stack<BinaryNode<T>> nodeStack1 = new Stack<>();	Stack<BinaryNode<T>> nodeStack2 = new Stack<>();    BinaryNode<T> currentNode = root;        if(currentNode == null){    	return;    }        nodeStack1.push(currentNode);        while(!nodeStack1.isEmpty()){    	    	BinaryNode<T> temp = nodeStack1.pop();    	nodeStack2.push(temp);    	    	if(temp.getLeftChild() != null){    		nodeStack1.push(temp.getLeftChild());    	}    	    	if(temp.getRightChild() != null){    		nodeStack1.push(temp.getRightChild());    	}    }        while(!nodeStack2.isEmpty()){    	    	BinaryNode<T> temp2 = nodeStack2.pop();    	System.out.print(temp2.getData() + " ");    }     }  /**   * Outputs exact same info as iterativeInorderTraverse()   * method but for levelorder traversal. You need to use    * Queue to implement this method iteratively. Simulate    * Queue using LinkedList.   *     */  public void iterativeLevelorderTraverse()  {	  	Queue<BinaryNode<T>> nodeQ = new LinkedList<>();    BinaryNode<T> currentNode = root;        nodeQ.add(currentNode);        while(!nodeQ.isEmpty()){    	    	BinaryNode<T> temp = nodeQ.poll();    	System.out.print(temp.getData() + " ");    	    	if(temp.getLeftChild() != null){    		nodeQ.add(temp.getLeftChild());    	}    	    	if(temp.getRightChild() != null){    		nodeQ.add(temp.getRightChild());    	}    }  }    private class PreorderIterator implements Iterator<T>  {	//You are allowed to create no more than	//2 data fields in this class.		/**	 * Private variable to store the stack	 */	private Stack<BinaryNode<T>> nodeStack;		/**	 * Private variable to point to the current node	 */	private BinaryNode<T> currentNode;		public PreorderIterator()	{	  nodeStack = new Stack<>();	  currentNode = root;	  if(currentNode != null){		  nodeStack.push(currentNode);	  }	}	public boolean hasNext()	{	  return !nodeStack.isEmpty() || (currentNode != null);	}	public T next()	{	  BinaryNode<T> nextNode = null;	  	  if(hasNext()){		  		  nextNode = nodeStack.pop();		  		  if(nextNode.getRightChild() != null){			  nodeStack.push(nextNode.getRightChild());		  }		  		  if(nextNode.getLeftChild() != null){			  nodeStack.push(nextNode.getLeftChild());		  }		  		  else{			  throw new NoSuchElementException();		  }	  }	  return nextNode.getData();	}  } // end PreorderIterator  private class PostorderIterator implements Iterator<T>  {	//You are allowed to create no more than	//2 data fields in this class.	/**	 * Private variable to store the stack	 */	private Stack<BinaryNode<T>> nodeStack;			/**	 * Private variable to point to the current node	 */	private BinaryNode<T> currentNode;		public PostorderIterator()	{	 nodeStack = new Stack<>();	 currentNode = root;	}	public boolean hasNext()	{	 	 return !nodeStack.isEmpty() || (currentNode != null);	}	public T next()	{		 BinaryNode<T> nextNode = null;	 	 while(currentNode != null){		 nodeStack.push(currentNode);		 		 if(currentNode.getLeftChild() == null){			 currentNode = currentNode.getRightChild();		 }		 		 else{			 currentNode = currentNode.getLeftChild();		 }	 }	 	 if(hasNext()){		 		 nextNode = nodeStack.pop();		 		 if(nodeStack.peek() != null && nextNode == nodeStack.peek().getLeftChild()){			 currentNode = nodeStack.peek().getRightChild();		 }		 		 else{			 currentNode = null;			 throw new NoSuchElementException();		 }	 }	 	 return nextNode.getData();	}  } // end PostorderIterator  private class LevelOrderIterator implements Iterator<T>  {	//You are allowed to create no more than	//2 data fields in this class.	  	/**	 * Queue to be used to hold the values	 */	private Queue<BinaryNode<T>> nodeQ;		/**	 * Private variable to point to the current node	 */	private BinaryNode<T> currentNode;		public LevelOrderIterator()	{	 	 nodeQ = new LinkedList<>();	 currentNode = root;	 if(currentNode != null){		 nodeQ.add(currentNode);	 }	}	public boolean hasNext()	{	 return !nodeQ.isEmpty() || (currentNode != null); 	}	public T next()	{	 	 BinaryNode<T> nextNode = null;	 	 if(hasNext()){		 		 nextNode = nodeQ.poll();		 		 if(nextNode.getLeftChild() != null){			 nodeQ.add(nextNode.getLeftChild());		 }		 		 if(nextNode.getRightChild() != null){			 nodeQ.add(nextNode.getRightChild());		 }		 else{			 throw new NoSuchElementException();		 }	 }	 return nextNode.getData();	}  } // end LevelOrderIterator} // end BinaryTree