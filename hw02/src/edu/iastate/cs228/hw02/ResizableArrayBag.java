package edu.iastate.cs228.hw02;import java.util.Arrays;/**   A class that implements a bag of objects by using an array.	The bag is never full.   @author Frank M. Carrano   @version 4.0*/public final class ResizableArrayBag<T> implements BagInterface<T>{	private T[] bag; // Cannot be final due to doubling	private int numberOfEntries;    private boolean initialized = false;	private static final int DEFAULT_CAPACITY = 25; // Initial capacity of bag	private static final int MAX_CAPACITY = 10000;	/** Creates an empty bag whose initial capacity is 25. */	public ResizableArrayBag() 	{		this(DEFAULT_CAPACITY);	} // end default constructor	/** Creates an empty bag having a given initial capacity.	    @param initialCapacity  The integer capacity desired. */	public ResizableArrayBag(int initialCapacity)	{      checkCapacity(initialCapacity);            // The cast is safe because the new array contains null entries      @SuppressWarnings("unchecked")      T[] tempBag = (T[])new Object[initialCapacity]; // Unchecked cast      bag = tempBag;      numberOfEntries = 0;      initialized = true;	} // end constructor	/** Creates a bag containing given entries.	    @param contents  An array of objects. */   public ResizableArrayBag(T[] contents)    {      checkCapacity(contents.length);      bag = Arrays.copyOf(contents, contents.length);      numberOfEntries = contents.length;      initialized = true;   } // end constructor       	/** Adds a new entry to this bag.       @param newEntry  The object to be added as a new entry.       @return  True. */	public boolean add(T newEntry)	{		checkInitialization();      if (isArrayFull())      {         doubleCapacity();      } // end if            bag[numberOfEntries] = newEntry;      numberOfEntries++;            return true;	} // end add	/** Retrieves all entries that are in this bag.       @return  A newly allocated array of all the entries in this bag. */	public Object[] toArray() 	{		checkInitialization();            // The cast is safe because the new array contains null entries.      @SuppressWarnings("unchecked")      T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast      for (int index = 0; index < numberOfEntries; index++)      {         result[index] = bag[index];      } // end for            return result;	} // end toArray   	/** Sees whether this bag is empty.       @return  True if this bag is empty, or false if not. */	public boolean isEmpty()	{      return numberOfEntries == 0;	} // end isEmpty   	/** Gets the current number of entries in this bag.       @return  The integer number of entries currently in this bag. */	public int getCurrentSize()	{      return numberOfEntries;	} // end getCurrentSize   	/** Counts the number of times a given entry appears in this bag.       @param anEntry  The entry to be counted.       @return  The number of times anEntry appears in this bag. */	public int getFrequencyOf(T anEntry)	{		checkInitialization();      int counter = 0;            for (int index = 0; index < numberOfEntries; index++)      {         if (anEntry.equals(bag[index]))         {            counter++;         } // end if      } // end for            return counter;	} // end getFrequencyOf   	/** Tests whether this bag contains a given entry.       @param anEntry  The entry to locate.       @return  True if this bag contains anEntry, or false otherwise. */   public boolean contains(T anEntry)	{		checkInitialization();      return getIndexOf(anEntry) > -1; // or >= 0	} // end contains   	/** Removes all entries from this bag. */	public void clear()	{      while (!isEmpty())         remove();	} // end clear		/** Removes one unspecified entry from this bag, if possible.       @return  Either the removed entry, if the removal       was successful, or null. */	public T remove()	{		checkInitialization();      T result = removeEntry(numberOfEntries - 1);      return result;	} // end remove		/** Removes one occurrence of a given entry from this bag.       @param anEntry  The entry to be removed.       @return  True if the removal was successful, or false if not. */	public boolean remove(T anEntry)	{		checkInitialization();      int index = getIndexOf(anEntry);      T result = removeEntry(index);      return anEntry.equals(result);	} // end remove    	// Locates a given entry within the array bag.	// Returns the index of the entry, if located,	// or -1 otherwise.   // Precondition: checkInitialization has been called.	private int getIndexOf(T anEntry)	{		int where = -1;		boolean found = false;		int index = 0;            while (!found && (index < numberOfEntries))		{			if (anEntry.equals(bag[index]))			{				found = true;				where = index;			} // end if         index++;		} // end while            // Assertion: If where > -1, anEntry is in the array bag, and it      // equals bag[where]; otherwise, anEntry is not in the array.      		return where;	} // end getIndexOf      // Removes and returns the entry at a given index within the array.   // If no such entry exists, returns null.   // Precondition: 0 <= givenIndex < numberOfEntries.   // Precondition: checkInitialization has been called.	private T removeEntry(int givenIndex)	{		T result = null;      		if (!isEmpty() && (givenIndex >= 0))		{         result = bag[givenIndex];          // Entry to remove         int lastIndex = numberOfEntries - 1;         bag[givenIndex] = bag[lastIndex];  // Replace entry to remove with last entry         bag[lastIndex] = null;             // Remove reference to last entry         numberOfEntries--;		} // end if            return result;	} // end removeEntry      // Returns true if the array bag is full, or false if not.	private boolean isArrayFull()	{		return numberOfEntries >= bag.length;	} // end isArrayFull      // Doubles the size of the array bag.   // Precondition: checkInitialization has been called.	private void doubleCapacity()	{      int newLength = 2 * bag.length;      checkCapacity(newLength);      bag = Arrays.copyOf(bag, newLength);	} // end doubleCapacity      // Throws an exception if the client requests a capacity that is too large.   private void checkCapacity(int capacity)   {      if (capacity > MAX_CAPACITY)         throw new IllegalStateException("Attempt to create a bag whose capacity exceeds " +                                         "allowed maximum of " + MAX_CAPACITY);   } // end checkCapacity      // Throws an exception if receiving object is not initialized.   private void checkInitialization()   {      if (!initialized)         throw new SecurityException ("Uninitialized object used " +                                      "to call an ArrayBag method.");   } // end checkInitialization   /**    * Method used to combine the entries of two bags into one    */   	@Override	public BagInterface<T> union(BagInterface<T> anotherBag) {	      		// Local variable to be returned as a union between two bags   		BagInterface<T> union = new ResizableArrayBag<T>();   		   		// Casts anotherBag to be a ResizableArrayBag   		ResizableArrayBag<T> otherBag = (ResizableArrayBag<T>)anotherBag;   		   		// Loop used to populate the union bag with values based on the numberOfEntries   		for(int i = 0; i < bag.length; i++){   			   			union.add(bag[i]); // Adds values to union   			   		}   		   		// Loop to add the values within the otherBag into the union bag   		for(int i = 0; i < otherBag.getCurrentSize(); i++){   			   			union.add(otherBag.bag[i]); // Adds otherBag's values to union   			   		}   			   return union; // Returns the combined union bag   	}   	/**   	 * Method that returns a new bag in which the contents are entries that occur in both bags   	 */   	@Override   	public BagInterface<T> intersection(BagInterface<T> anotherBag) {	      		BagInterface<T> intersection = new ResizableArrayBag<T>();   		   		ResizableArrayBag<T> otherBag = (ResizableArrayBag<T>)anotherBag;   		   		// Create a copy of the bag   		ResizableArrayBag<T> copy = new ResizableArrayBag<T>();   		   		// Copy all entries to the copy of this bag   		for (int i = 0; i < otherBag.numberOfEntries; i++){   			copy.add(otherBag.bag[i]);   		}   		   		// Loops to check for similar entries   		for(int i = 0; i < getCurrentSize(); i++){   			   			// If the both bags have the same value, adds the value at the index to the intersection   			if(copy.contains(bag[i])){   			   				intersection.add(bag[i]); // adds value to intersection   				copy.remove(bag[i]); // remove    			}   		}	   		return intersection; // Returns the new bag which contains entries that occur in both bags   	}   	/**   	 * Method that returns a new bag after removing duplicate values from both of the bags   	 */   	@Override   	public BagInterface<T> difference(BagInterface<T> anotherBag) {   		   		// Local variable to be returned as a new bag of entries to be left in one bag after removing those which occur in the second   		BagInterface<T> difference = new ResizableArrayBag<T>();   		   		// Casts anotherBag as a ResizableArrayBag   		ResizableArrayBag<T> otherBag = (ResizableArrayBag<T>)anotherBag;	   		// Loop to populate the difference bag with values based on the numberOfEntries   		for(int i = 0; i < bag.length; i++){   			difference.add(bag[i]);   		}   		   		// Loop to modify the difference bag based on the contents of the otherBag   		for(int i = 0; i < otherBag.getCurrentSize(); i++){   			   			// If otherBag and difference contain the same entry, remove it from difference   			if(difference.contains(otherBag.bag[i])){   				   				difference.remove(otherBag.bag[i]); // Removes the entry   			}   		}   		return difference; // Returns the new bag after removing duplicate entries    	}   	/**   	 * Method that replaces and returns any object currently in the bag with a given object   	 */   	@Override   	public T replace(T replacement) {   		   		// Local variable to store the entry to be replaced   		T entryReplaced = null;   		   		// If bag is empty return null   		if(isEmpty()){   			return null;   		}   		   		// Loop that iterates through the bag to replace values   		for(int i = 1; i < bag.length; i++){   			   			// Checks to see if the value at the index is empty or null   			if(!isEmpty() && !(bag[i] == null)){   				   				// Sets local variable equal to value at the indicated index   				entryReplaced = bag[i-1];   				   				// Stores that value in the replacement variable   				bag[i-1] = replacement;   			}   		}	   		return entryReplaced; // Returns replaced entry   	}   	/**   	 * Method that removes all occurrences of a given entry    	 */   	@Override   	public void removeEvery(T anEntry) {   		   		// Loops through the entry   		for(int i = 0; i < bag.length; i++){   			   			// Enter into the if statement if the value at anEntry equals the bag value   			if(anEntry.equals(bag[i])){   				   				removeEntry(i); // Removes the entry   				   				i-=1; // Decreases i so that it stays at the first index if an Entry is removed   			}   		}	   	}   	   	/**   	 * Overrides the equals method of the Object class so that it returns true when   	 * the contents of the two bags are the same   	 * @param anotherBag    	 * @return    	 * true or false depending on whether or not the bags are equal   	 */   	public boolean equals(BagInterface<T> anotherBag){   		   		// If o is null or the classes of the objects differ, return false   		if(anotherBag == null || anotherBag.getClass() != this.getClass()){   			return false;   		}   		   		ResizableArrayBag<T> other = (ResizableArrayBag<T>) anotherBag; // Casts o as a ResizableArrayBag   		   		// If the objects are different lengths return false   		if(this.numberOfEntries != other.numberOfEntries){   			   			return false;   			   		}   		   		// Loops through to check the size and entries of both ResizableArrayBags   		for(int i = 0; i < numberOfEntries; i++){   			   			// Checks to see the number of entries of both are the same   			if(this.numberOfEntries == other.numberOfEntries){   				   				// Checks to see the value of the entry at each index is the same   				if(this.bag[i] == other.bag[i]){   					   					return true; // Returns true if all conditions are met   					   				}   			}   		}   		   		return false; // Returns false by default   	}} // end ResizableArrayBag