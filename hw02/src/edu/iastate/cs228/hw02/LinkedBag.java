package edu.iastate.cs228.hw02;/**   A class of bags whose entries are stored in a chain of linked nodes.	The bag is never full.   @author Frank M. Carrano   @author Timothy M. Henry   @version 4.1*/public final class LinkedBag<T> implements BagInterface<T>{	private Node firstNode;       // Reference to first node	private int numberOfEntries;	public LinkedBag()	{		firstNode = null;      numberOfEntries = 0;	} // end default constructor	/** Sees whether this bag is empty.	    @return  True if this bag is empty, or false if not. */	public boolean isEmpty() 	{		return numberOfEntries == 0;	} // end isEmpty	/** Gets the number of entries currently in this bag.	    @return  The integer number of entries currently in this bag. */	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	/** Adds a new entry to this bag.	    @param newEntry  The object to be added as a new entry	    @return  True if the addition is successful, or false if not. */	public boolean add(T newEntry)  	      // OutOfMemoryError possible	{      // Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode; // Make new node reference rest of chain                                // (firstNode is null if chain is empty)              firstNode = newNode;      // New node is at beginning of chain		numberOfEntries++;      		return true;	} // end add	/** Retrieves all entries that are in this bag.	    @return  A newly allocated array of all the entries in this bag. */	public Object[] toArray()	{      // The cast is safe because the new array contains null entries      @SuppressWarnings("unchecked")      T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast      int index = 0;      Node currentNode = firstNode;      while ((index < numberOfEntries) && (currentNode != null))      {         result[index] = currentNode.data;         index++;         currentNode = currentNode.next;      } // end while      			return result;	} // end toArray	/** Counts the number of times a given entry appears in this bag.		 @param anEntry  The entry to be counted.		 @return  The number of times anEntry appears in this bag. */	public int getFrequencyOf(T anEntry) 	{		int frequency = 0;      int counter = 0;      Node currentNode = firstNode;      while ((counter < numberOfEntries) && (currentNode != null))      {         if (anEntry.equals(currentNode.data))         {            frequency++;         } // end if                  counter++;         currentNode = currentNode.next;      } // end while		return frequency;	} // end getFrequencyOf	/** Tests whether this bag contains a given entry.		 @param anEntry  The entry to locate.		 @return  True if the bag contains anEntry, or false otherwise. */	public boolean contains(T anEntry)	{      boolean found = false;      Node currentNode = firstNode;            while (!found && (currentNode != null))      {         if (anEntry.equals(currentNode.data))            found = true;         else            currentNode = currentNode.next;      } // end while	            return found;   } // end contains    	// Locates a given entry within this bag.	// Returns a reference to the node containing the entry, if located,	// or null otherwise.	private Node getReferenceTo(T anEntry)	{		boolean found = false;		Node currentNode = firstNode;				while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while     		return currentNode;	} // end getReferenceTo   /** Removes all entries from this bag. */	public void clear() 	{		while (!isEmpty())          remove();	} // end clear		/** Removes one unspecified entry from this bag, if possible.       @return  Either the removed entry, if the removal                was successful, or null. */	public T remove()	{		T result = null;      if (firstNode != null)      {         result = firstNode.data;          firstNode = firstNode.next; // Remove first node from chain         numberOfEntries--;      } // end if		return result;	} // end remove		/** Removes one occurrence of a given entry from this bag, if possible.       @param anEntry  The entry to be removed.       @return  True if the removal was successful, or false otherwise. */   public boolean remove(T anEntry) 	{		boolean result = false;      Node nodeN = getReferenceTo(anEntry);            if (nodeN != null)      {         nodeN.data = firstNode.data; // Replace located entry with entry in first node                  firstNode = firstNode.next;  // Remove first node         numberOfEntries--;                  result = true;      } // end if         		return result;	} // end remove	private class Node 	{	  private T    data; // Entry in bag	  private Node next; // Link to next node		private Node(T dataPortion)		{			this(dataPortion, null);			} // end constructor				private Node(T dataPortion, Node nextNode)		{			data = dataPortion;			next = nextNode;			} // end constructor	} // end Node	/**	 * Returns a new bag of entries that is the combined entries of both bags	 */	@Override	public BagInterface<T> union(BagInterface<T> anotherBag) {				// Local variable to be returned as a union between two bags		BagInterface<T> union = new LinkedBag<T>();				// Casts anotherBag to a LinkedBag		LinkedBag<T> otherBag = (LinkedBag<T>)anotherBag;				// Local variable to store the first node		Node firstNode = this.firstNode;				// While there are contents in the firstNode, populates the union bag		while(firstNode != null){			union.add(firstNode.data); // Adds data to union			firstNode = firstNode.next; // Sets the firstNode equal to the next node		}				// While there are contents in the otherBag.firstNode, populates the union bag with the values from otherBag		while(otherBag.firstNode != null){			union.add(otherBag.firstNode.data); // Adds data to union			otherBag.firstNode = otherBag.firstNode.next; // Sets firstNode equal to the next node		}				return union; // Returns a combined union bag 	}	/**	 * Returns a new bag of entries that contains entries that occur in both bags	 */	@Override	public BagInterface<T> intersection(BagInterface<T> anotherBag) {				// Local variable to be the intersection between two bags		BagInterface<T> intersection = new LinkedBag<T>();				// Casts anotherBag to be a LinkedBag		LinkedBag<T> otherBag = (LinkedBag<T>)anotherBag;				// Create a copy of the bag		LinkedBag<T> copy = new LinkedBag<T>();				// Local variable to store the first node		Node firstNode = this.firstNode;				// Populates the copy variable with values		while(firstNode != null){						copy.add(firstNode.data);			firstNode = firstNode.next;					}				Node n = otherBag.firstNode; 				while(otherBag.firstNode != null){						// If copy has value of otherBag in it add to intersection and remove from copy			if(copy.contains(otherBag.firstNode.data)){								intersection.add(otherBag.firstNode.data);				copy.remove(otherBag.firstNode.data);				otherBag.firstNode = otherBag.firstNode.next;			}			else{				//copy.remove(otherBag.firstNode.data);				otherBag.firstNode = otherBag.firstNode.next;			}		}				otherBag.firstNode = n; // So that otherBag is not null				return intersection; // Return intersection of two bags	}	/**	 * Returns a new bag of entries that would be left after removing those that occur in the second	 */	@Override	public BagInterface<T> difference(BagInterface<T> anotherBag) {				// Local variable to be returned as a new bag of entries to be left in one bag after removing those which occur in the second		BagInterface<T> difference = new LinkedBag<T>();				// Casts anotherBag as a LinkedBag		LinkedBag<T> otherBag = (LinkedBag<T>)anotherBag;				// Local variable to store the value of the first node		Node firstNode = this.firstNode;				// Populates the difference variable with values		while(firstNode != null){			difference.add(firstNode.data);			firstNode = firstNode.next;		}				Node n = otherBag.firstNode;				while(otherBag.firstNode != null){						// If difference contains value in otherBag remove it from the bag			if(difference.contains(otherBag.firstNode.data)){				difference.remove(otherBag.firstNode.data);				otherBag.firstNode = otherBag.firstNode.next;			}			else{				//difference.remove(otherBag.firstNode.data);				otherBag.firstNode = otherBag.firstNode.next;			}		}				otherBag.firstNode = n; // So that otherBag isn't null				return difference; // Returns difference of the two bags	}	/**	 * Replaces and returns any object currently in a bag with a given object	 */	@Override	public T replace(T replacement) {				T entryReplaced = null; // Entry to be replaced				Node firstNode = this.firstNode; // Variable for the first node						if(isEmpty()){						return null; // If empty return null					}		// While it's not empty and there are no null values loop through 		while(!isEmpty() && firstNode != null){						// If there is a next value hop into the if statement			if(firstNode.next != null){								entryReplaced = firstNode.data; // Set the entry replaced to be the firstNode data							firstNode.data = replacement; // Set the firstNode data equal to the local variable			}						firstNode = firstNode.next; // Sets firstNode to the next value		}						return entryReplaced; // Returns the replaced entry	}	/**	 * Removes all occurrences of a given entry from a bag	 */	@Override	public void removeEvery(T anEntry) {				// Stores value of the first node		Node firstNode = this.firstNode;				while(firstNode != null){						// If value at first node equals the entry, remove and continue 			if(firstNode.data == anEntry){								this.remove(anEntry); // Removes entry			}						firstNode = firstNode.next; // Updates firstNode		}			}		/**	 * Overrides the equals method of the object class so that it returns 	 * true when the contents of the two bags are the same	 * @param anotherBag	 * @return 	 * true if the bags are equal and false otherwise	 */	public boolean equals(BagInterface<T> anotherBag){				LinkedBag<T> otherBag = (LinkedBag<T>)anotherBag; 				Node firstNode = this.firstNode;				// If bag is null return false		if(otherBag == null || otherBag.getClass() != this.getClass() || otherBag.getCurrentSize() != this.getCurrentSize()){						return false;					}				while(firstNode != null){						// If the values differ between the two bags return false			if(!(otherBag.contains(firstNode.data))){								return false;							}						// If the occurrence of each value in each bag differs, return false			else if(this.getFrequencyOf(firstNode.data) != otherBag.getFrequencyOf(firstNode.data)){								return false;							}						firstNode = firstNode.next; // Updates firstNode		}				return true; // Default to true	}	} // end LinkedBag