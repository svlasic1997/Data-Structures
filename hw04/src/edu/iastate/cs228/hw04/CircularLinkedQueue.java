package edu.iastate.cs228.hw04;/** *  * @author Scott Vlasic	 *  * NOTE:  * 0. Put your Firstname and Lastname after above author tag. * 	  Make sure that in both cases the first letter is uppercase *    and all others are lowercase (and space in between). * 1. You are allowed to create and use your own private helper methods.  * 2. No additional data fields can be introduced. * 3. No custom classes of your own can be introduced or used. * 4. Import statements are not allowed. * 5. Fully qualified class names usage is not allowed. * 6. You are allowed to reuse any part of the source codes provided *    or shown under lecture notes of week 5 (or before). * 7. You are not allowed to create arrays of objects and manipulate *    queue objects using arrays.    * * * * DESCRIPTION: * A class that implements the ADT queue by using a circular linked chain of nodes.  * For details of circular linked chain check slide number 28 of * "queueDequePriorityQueueImplementations_part2.pdf" file under lecture notes  * of Wednesday of Week 5 on Canvas. This slide shows a circular linked chain with  * an external reference to its last node that (a) shows a case when we have more than  * one node; (b) has one node; (c) is empty. *   *  */public class CircularLinkedQueue<T> implements QueueInterface<T>{	private Node lastNode; // References node for back of queue	public CircularLinkedQueue() 	{		lastNode = null;	}	public void enqueue(T newEntry) 	{		// Temp variable for node to be added at the beginning		Node n = new Node(newEntry);				// Adds to the front if the list is empty		if(isEmpty()){			lastNode = n;			n.setNextNode(lastNode);		}				else{						// 			if(lastNode.getNextNode() == null){				lastNode.setNextNode(n);				n.setNextNode(lastNode);			}						else{								// 				n.setNextNode(lastNode.getNextNode());				lastNode.setNextNode(n);			}		}				lastNode = n;	}	public T dequeue() 	{		T dequeued = null;				if(isEmpty()){			throw new EmptyQueueException();		}				if(lastNode.getNextNode().equals(lastNode)){			dequeued = lastNode.getData();			lastNode.setData(null);			lastNode.next = null;			return dequeued;		}				else{			Node removed = lastNode.getNextNode();			Node firstNode = lastNode.getNextNode().getNextNode();						dequeued = removed.getData();			removed.next = null;						lastNode.next = firstNode;			return dequeued;		}	}	public T getFront() 	{		T firstNode = null; // Local variable to see if isEmpty is true				if(isEmpty()){						throw new EmptyQueueException();		}				else{						firstNode = lastNode.getNextNode().getData();					}				return firstNode; // Else return null	}	public boolean isEmpty() 	{		// Empty if there is no value 		if(lastNode == null){						return true;					}				// Empty if there is no next value		if(lastNode.next == null){						return true;					}				return false;	}	public void clear() 	{		lastNode = null; // Assigns lastNode to null, clearing the queue	}	private class Node	{		private T    data;  // Queue entry		private Node next;  // Link to next node		private Node(T dataPortion)		{			data = dataPortion;			next = null;			} // end constructor				private Node(T dataPortion, Node linkPortion)		{			data = dataPortion;			next = linkPortion;			} // end constructor		private T getData()		{			return data;		} // end getData		private void setData(T newData)		{			data = newData;		} // end setData		private Node getNextNode()		{			return next;		} // end getNextNode				private void setNextNode(Node nextNode)		{			next = nextNode;		} // end setNextNode	} // end Node} // end CircularLinkedQueue